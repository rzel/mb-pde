## Statement of the problem ##
Software design patterns abstract reusable object-oriented software design. Each pattern solves design problems that occur in every day software development. The detection of design patterns during the process of software re-engineering provides a better and faster understanding of the software system.
The first time the term 'Design Pattern' was related to Software Development was in the book "Design Patterns - Elements of Reusable Object-Oriented Software" written by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides. The group of authors is also know as the "Gang-of-Four" or "GoF". They discuss object-oriented design techniques that are based on their experience as software developers. They introduce 23 design pattern using a consistent format of information for each pattern to provide a uniform structure. Using the intent, trade-offs and graphical notations for design patterns, software engineers can decide which design pattern solves their design problems. It also makes it easier to discuss design problems and solutions with colleagues by using a common syntax. It is also useful documenting which design patterns have been used in a software so that other developers will get a better overview of the software without having to read the source code in detail.
This thesis will work on the problem of detecting software design patterns. We will provide a tool that will detect the original 23 software design pattern using their static structure as described in class diagrams and using their dynamic structure. The results can be used to verify the implementation of design patterns that were specified before the implementation phase. The found design patterns can also be added to the documentation to make it easier for developers to understand different parts of the code easier and faster. Having these additional information can be very crucial during software maintenance. If a good design of a software is poorly documented then this good design might be broken by a different developer that needed to add another functionality. In future these changes might introduce new bugs and problems and lead to degradation of the software. Therefore it is important to document these design choices and to improve the understanding of the software.


## Approach ##
Design patterns abstract reusable object-oriented software design. Each pattern solves design problems that occur in every day software development. Having knowledge of the existence of a design pattern in the source code will lead to a better and faster understanding of the software and the source code. Each pattern has its own unique intent and is described with roles and responsibilities. In the source code, each role is commonly represented by a class and the responsibilities are coded in the classes with attributes and methods. The patterns also describe the collaboration between objects at runtime. Our approach is to extract design pattern candidates in the source code and find design patterns. In this thesis, we will use the roles, responsibilities and collaboration information to analyze software, detect design patterns and rank the results by their classification. Understanding the structure and intent of the software system will give the developer a faster overview of the whole system without going into details of the source code.

Figure 1 shows an excerpt of a software system represented in UML notation. After the detection process our software will show all classes that match design patterns. In UML notation, classes are represented as boxes with the class name as a title and the dependency and association relationships shown as arrows going from one class to another. During the detection process we will use this information to detect the design pattern. We will use the Adapter design pattern as a running example in this chapter to present the approach that uses all of the developed features of our software.
The intent of the Adapter is to convert the interface of a class into another interface the clients expect. Adapter lets classes work together that could not otherwise because of incompatible interfaces. The Adapter design pattern consists of four classes.

  * A target interface that represents the contract between the adapter class and the clients that want to use the adapter.
  * An adapter that holds a reference to the adaptee and translates target methods to adaptee methods.
  * An adaptee that has the actual implementation that the client wants to use.
  * One or more clients that want to use a specific functionality.


![http://www.cse.yorku.ca/~mbirkner/website/images/SoftwareSystemAdapterPattern.png](http://www.cse.yorku.ca/~mbirkner/website/images/SoftwareSystemAdapterPattern.png)

Figure 1: The left side shows a UML diagram of a software system. The right side shows a UML diagram of the Adapter design pattern that we want to detect.



Our approach in detecting design patterns is divided into static and dynamic analysis. During the static analysis we take the class files and extract static facts from the software. The results include class names, relationships between classes and attributes of the classes. These facts are then processed to find possible candidate instances that match the UML notation of a design pattern. In the next step of the detection we instrument the byte code of the software, execute the software and record all method calls of the running instances. For the dynamic analysis it is important to execute as many methods in the software as possible. Good test suites will help to obtain good dynamic facts since they call most of the implemented method. The facts from the dynamic analysis and the candidate instances from the static analysis are then processed together to detect design patterns according to the static and dynamic definitions of the patterns. After the detection process our software ranks the found design pattern instances according to how well they match the static and dynamic definitions. We will provide static and dynamic definitions for the original software design patterns from the GoF book. Figure 2 presents the described steps. Our software can be extended by using its results and specifying more rules upon the design patterns.

![http://www.cse.yorku.ca/~mbirkner/website/images/DetectionProcessNewImplemented.png](http://www.cse.yorku.ca/~mbirkner/website/images/DetectionProcessNewImplemented.png)

Figure 2: Detection Process